pragma solidity 0.5.12;

import "./DocumentStore.sol";
import "@openzeppelin/contracts-ethereum-package/contracts/cryptography/ECDSA.sol";
import "@openzeppelin/upgrades/contracts/Initializable.sol";
import "@openzeppelin/contracts-ethereum-package/contracts/ownership/Ownable.sol";

/**
 * @dev This contract enables meta-transactions to be sent and delegated to a third party.
  *     Two roles are required: 1. relayer and 2. trustedSigner. Each being Externally Owned Accounts (EOAs).
  *     The relayer is the third party that is signing and paying for the transactions on behalf of the trustedSigner.
  *     The trusteSigner is the issuing party that is required to sign the actual messages and transaction data.
  *     This contract then relays transactions to the OpenAttestation DocumentStore on behalf of the trusedSigner.
  *     The most notable parameters that have been added to extend the DocumentStore are:
  *       1. nonce: Leveraged in order to protect against replay attacks although this risk is quite low as issuance / revocation
  *                 may only occur once by design.
  *       2. documentsHash: The hash of an array of documentMerkleRoots that are being bulk issued / revoked. Only for bulk operations.
  *                         - const message = web3.utils.soliditySha3(...documentMerkleRoots);
  *       3. signature: The off-chain signature, signed with the privateKey from the trustedSigner EOA, that will be used to
  *                     authenticate the trustedSigner and verify the transaction.
  *     ---
  *     The process for generating a valid signature is as follows:
  *       1. Generate the message to be signed. This will be either the docuementMerkleRoot or the documentsHash of an array of docuementMerkleRoots (for batch operations).
  *         - const message = "0x3a267813bea8120f55a7b9ca814c34dd89f237502544d7c75dfd709a659f6330"; // documentMerkleRoot
  *         OR
  *         - const documentMerkleRoots = ["0x3a267813bea8120f55a7b9ca814c34dd89f237502544d7c75dfd709a659f6330", "...", ...];
  *           const message = web3.utils.soliditySha3(...documentMerkleRoots); // hash of many documentMerkleRoots for a batch operation
  *       2. Generate the nonce... transaction count... random number etc.
  *       3. Generate the signature.  This signature is generated by signing the hash of: the nonce, the message as well as the relay contract addres.
  *          The relay contract address is used to also elimiate the risk of replay attacks across other relay contracts.
  *          The resulting signature should be in hex format following the Ethereum signature encoding.
  *          For example:
  *           - const message = "0x3a267813bea8120f55a7b9ca814c34dd89f237502544d7c75dfd709a659f6330";
  *             const nonce = 1;
  *             const address = contract.address; // 0x8CdaF0CD259887258Bc13a92C0a6dA92698644C0
  *             const messageHash = web3.utils.soliditySha3(message, nonce, address); // 0x2bd7dce779d8d21e3266e847f21ce8160a53e6a78a65a5045f72b18081f7fc69
  *             const signature = await web3.eth.sign(messageHash, signer); // 0xf5731da089e7d9532aad446f9f92cabf3ce39c5cde8ba541cb26ed17b69ab8870a411a66ad8316d7b7478e1c1be05ca840ecfc8cc7468beb9c2832be4dc8fb1e1b
 */
contract RelayedDocumentStore is Initializable, Ownable {
  using ECDSA for bytes32;

  address private trustedSigner; // Account that is signing *messages*
  DocumentStore public documentStore;

  mapping(address => uint256) public signerNonce;

  event DocumentIssued(bytes32 indexed document);
  event DocumentRevoked(bytes32 indexed document);
  event RelayedMessage(address indexed relayer, address indexed trustedSigner, bytes4 functionIdentifier);

  function initialize(
    string memory _name,
    address _trustedSigner,
    address _relayer
  )
    public
    initializer
  {
    // Owner of this contract is the relayer
    require(_relayer != address(0), "RelayedDocumentStore: relayer is the zero address");
    super.initialize(_relayer);

    require(_trustedSigner != address(0), "RelayedDocumentStore: trustedSigner is the zero address");
    trustedSigner = _trustedSigner;

    // Owner of the DocumentStore is this contract enforcing trustedSigner sign-off
    documentStore = new DocumentStore();
    documentStore.initialize(_name, address(this));
  }

  function bulkIssueRelayed(
    bytes32[] memory documents,
    bytes32 documentsHash,
    bytes memory signature
  )
    public
    onlyOwner
    onlyTrustedSigner(documentsHash, signature)
  {
    documentStore.bulkIssue(documents);
  }

  function bulkRevokeRelayed(
    bytes32[] memory documents,
    bytes32 documentsHash,
    bytes memory signature
  )
    public
    onlyOwner
    onlyTrustedSigner(documentsHash, signature)
  {
    documentStore.bulkRevoke(documents);
  }

  function issueRelayed(
    bytes32 document,
    bytes memory signature
  )
    public
    onlyOwner
    onlyTrustedSigner(document, signature)
  {
    documentStore.issue(document);
  }

  function revokeRelayed(
    bytes32 document,
    bytes memory signature
  )
    public
    onlyOwner
    onlyTrustedSigner(document, signature)
  {
    documentStore.revoke(document);
  }

  /**
   * @dev Throws if the message is not signed by the trusted signer or nonce incorrect.
   */
  modifier onlyTrustedSigner(bytes32 message, bytes memory signature) {
    uint256 nonce = signerNonce[trustedSigner];
    bytes memory blob = abi.encodePacked(message, nonce, address(this));
    address recoveredAddress = keccak256(blob).toEthSignedMessageHash().recover(signature);
    require(recoveredAddress == trustedSigner, "RelayedDocumentStore: Signature does not match the trustedSigner");

    ++signerNonce[trustedSigner];

    emit RelayedMessage(msg.sender, recoveredAddress, msg.sig);
    _;
  }
}
